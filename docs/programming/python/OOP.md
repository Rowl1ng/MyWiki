# 面向对象编程（OOP）

data+action:与真实世界中的**实体**相仿，有独立的数据和动作，自己和自己、和其他对象之间都可以且**仅**能(**封装**)通过定义好的**接口**进行交互。这样一来，也就方便了解决真实世界中的问题（**建模**过程：abstract+
realization），因为其属性可通过**类变量**来定义，其动作、变化可通过**方法**来描述。

- 类(Class): 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。`Object`是“所有类之母”，若没有继承其他类，它将作为默认的父类。命名。eg. `AddrBookEntry`
- 类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。相当于`static`。使用名词做名字。
    - 查看类的属性：
        - 特殊类属性`__dict__` 
            - `dict()`内建函数
        - `@property`：[教程][8]
            - private variable常用`_`开头，例如`_tempreature`，而`tempreature`则是提供对外接口的property
- 实例化：创建一个类的实例，类的具体对象。
    - 实例化过程中调用`__init__()`方法，实例化本身更像是对`__init__()`的隐式调用。
    - ps:如果变量没有默认值，则实例化时必须传进去。
- **方法**：类中定义的函数。定义在类中的方法只能被实例调用。使用v+n，eg.`updatePhone`,“混合记法”。或者`update_phone`
    - `self`表示实例本身，实例在调用方法时将自己“悄悄”传过去。 对应其他语言的`this`。
    - 一般方法都需要`self`作为第一个参数传进去；静态方法不需要；类方法需要的是类而不是实例。
    - 方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。
- 实例变量：定义在方法中的变量，只作用于当前实例的类。
- 继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟"是一个（is-a）"关系（例图，Dog是一个Animal）。

- 对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。

### super()

用来查找父类的属性

```python
super(MyClass,self).__init__()
```

这里调用了`MyClass`的父类的`__init__()`方法。由此看来，`super`不但能找到父类方法，还能帮忙传入`self`。（注意这里是在子类方法中调用`__init__()`，而不是用实例调用，即**未绑定**需要手动传递`self`）
应用场景：在子类中覆盖了父类的`__init__()`方法，导致被实例化的时候只调用子类的，而不调父类的。这时若还想调父类的，就可以像上面这样。这就像是先走一遍基类（父类）的初始化流程（做准备工作），之后再走子类的。

> 对比：
    - Java总是会去调用基类的构造器；
    - C++通过在构造子类的构造器时，在声明后加冒号和要用的所有基类构造器。
  

# Inbox

python OOP组合、继承



