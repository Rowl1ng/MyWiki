# 关于CRS中的自动化漏洞检测和攻击代码生成研究综述

## Abstract
DARPA主办的Cyber Grand Challenge(CGC)是一个面向实现自动化漏洞挖掘、攻击脚本生成和软件补丁功能的当前最新系统的竞赛。本文分析了两个赢家系统Mayhem和Mechanical Phish的漏洞检测、攻击脚本生成、底层技术和相关工作。

DARPA sponsored the Cyber Grand Challenge(CGC), a competition to showcase the current state-of -the-art systems that performs: automated vulnerability detection, exploit generation and software patching. This paper is a survey of the vulnerability detection and exploit generation techniques, underlying technologies and related works of two of the winning systems Mayhem and Mechanical Phish.

## 引言
从满足日常所需到执行关键任务，信息技术正影响着我们生活的方方面面。这引发了人们对安全性的诸多顾虑，进而推动了对自动化、可拓展、可靠的方法的探索，以更有效地发现、验证、弥补可利用的漏洞。为了加速该领域的研究进展，美国国防部先进项目研究局(DARPA)于2013年发起了全球性网络安全竞赛（Cyber Grand Challenge）\footnote{\url{https://sites.google.com/site/bletchleypark2/misc/cyber-grand-challenge}}
，即CGC。举办CGC的主要原因是日益严重的网络安全问题，而目前基于漏洞的软件安全攻防很大程度上依赖于人。CGC的目标是推动程序自动攻防的能力并超越人的手动能力，最终实现全自动的网络安全攻防系统。也就是说，CGC的参赛队伍全部都是代表着机器程序的战队，可以将其视作机器黑客CTF（Capture the Flag）战队。

一般CTF竞赛需要大量人力参与分析，而实际网络攻防也面临相同问题，即需要花费大量人力来应对新的攻击，造成从攻击出现到到防御机制中间有时间差，也就是我们常听到的zero-day所造成的信息安全问题。传统人工防御机制大约需要24天来应对新产生的攻击。因此若能自动化生成防御机制，便能大幅降低攻击和防御手法间的时间差，保护更多的信息系统。

现如今，机器的运算速度及基本理论已经有长足的进步，许多软件测试及分析的技术与基本理论都日趋完善，虽然许多技术要应用在大型环境中还有一段差距值得研究者们努力，但已经可以一定程度的自动化找出并修补程序漏洞。以下是DARPA文件中有提及的技术：
\begin{itemize}
-	Dynamic Analysis
-   Static Analysis
-   Symbolic Execution
-	Constraint Solving
-	Data Flow Tracking
-	Fuzz Testing
\end{itemize}   

全自动的CRS(Cyber Reasoning System)的目标是自动化防御网络攻击。此系統必须首先对待测程序进行分析，自动推理出漏洞的位置。接着产生能夠触发该漏洞的测试样例，来证明漏洞真实存在。最后产生修补该漏洞的方式。当然，整个过程需要全程的自动化。

### 对研究的影响

在其他与智能系统开发相关的计算机科学研究领域，如机器学习和人工智能，总有大量开放数据集、语料库以及对应的评价基准，因此研究者们可以跨技术、跨平台地评估他们方法的效果。其中最有名的当属“MNIST 手写数字数据集”。该数据集有一段历史基准数据可供参照，并提供标准数据集供训练神经网络及其他机器学习算法。而在安全研究领域，尤其是在二进制分析领域，大多数分析技术的评估都是基于不同的数据集、不同的平台，因此很难比较不同方法孰优孰劣。

CGC的组织者设计了一系列挑战，它们是复杂性、文件大小和功能各不相同的二进制文件。设计目的在于使得分析它们的系统也能应用于真实场景中的软件。除了这些二进制代码，还有一个为叫做 DECREE OS 的专为竞赛设计的 Ubuntu 系统共同组成标准平台和数据集，这样参赛者可以直接在该平台上评估他们的系统。

**CGC打分**
CGC基于安全性、可用性对参赛系统进行评估。通过运行CGC组织方提供的测试来验证补丁二进制文件（挑战的替换二进制文件），这些测试采用漏洞验证（POV）的形式。如果参赛系统没能防御任何POV，其安全得分为0。此外，比赛基于系统资源的开销来对补丁二进制文件进行打分，如内存、CPU使用以及文件大小。值得注意的是，和补丁程序一道提交有效的POV的话安全得分会加倍。需要进一步说明的是，打分系统推荐参赛系统的重心放在二进制补丁上，而不是放在可利用漏洞的数量上。

本文接下来几节将探讨CGC赢家系统Mayhem和Mechanical Phish的攻击能力、底层技术和相关工作，同时提出自动化二进制分析系统攻击能力未来可能的研究方向。

## 背景
即使开发者尽最大努力，bug总难尽除，而我们的日常生活对信息系统的依赖又在与日俱增，对软件、硬件安全性、可靠性的保障也就成了大量安全研究者的关注重点。由于很多情况下我们只能获取到二进制代码供分析，二进制软件分析尤为重要。这在检测嵌入式固件、定制操作系统和恶意软件时更加得到印证。

二进制分析的难点在于：我们失去了编程语言提供的抽象，比如数据类型和数据结构。而这些抽象简化了对数据和输入驱动执行路径的推断过程。尽管这些挑战的设计对二进制分析有先天优势。二进制文件往往包含只有运行时可得的平台特定细节，比如“内存布局、寄存器使用和执行顺序”对检测诸如内存破坏、缓冲区溢出在内的常见漏洞类型很重要。出于包括以上几点的一些原因，二进制分析作为一种特定类型的程序分析，成为了近年来安全研究者们的研究重点之一，而且待检测软件的庞大数量也激发了人们对能大量分析二进制软件的自动化二进制分析系统的强烈兴趣。

静态、动态混合分析（concolic analysis，也被称为动态符号分析）是三种常用的二进制分析方法。每种方法都有自己的强项和弱项，为了应对真实场景软件的挑战，每种方法也都有其自身需要处理的一些设计考虑。接下来的几节将具体分析每种方法，包括他们的缺陷、优势以及构造高效的自动化漏洞挖掘和攻击脚本生成系统时的设计思想。
## 设计思想
在设计自动化漏洞检测和攻击脚本生成系统时需要考虑的关键一点就是确保系统能重放或复现触发程序漏洞时的程序状态（例如用户输入或数据）。另一个关键点在于系统必须在语义层面上理解是输入的哪一部分造成了我们观测到的行为。这些要考虑的问题直接影响到系统返回结果的可扩展性和可靠性。举个例子，像符号执行这样旨在高复现率和高语义理解程度的的分析技术在可扩展性上会受阻，而偏向可重放性的技术则代码覆盖率较低。
## 静态二进制分析 
静态二进制分析是不运行条件下对二进制文件的分析。静态二进制分析过程往往首先加载并处理要分析的二进制文件。处理步骤包括对二进制进行句法分析、生成二进制文件的汇编指令的中间语言表示以及构造\emph{控制流图}（CFG）。控制流图展示了程序执行过程中可采取的路径。图的节点表示基本的机器指令块，边表示控制流在这些节点之间的可能转换点。控制流图是采用静态二进制分析的自动化漏洞检测系统的关键组件，因为它帮助系统探索应用中的所有可执行路径。

- 静态二进制分析的局限性：尽管该技术使得系统能检测到所有可能的程序路径，却牺牲了可扩展性和表现。静态二进制分析通常很慢，在处理间接跳转语句时也受限。在构造CFG时处理非直接跳转语句要比直接跳转语句更难，应为此时应用在把控制传给一个目标，而这个目标的值有可能是随机计算得到或依赖于应用上下文的。为了解决这些限制，静态二进制分析工具对应用的控制流做逼近，因此也冒着完全不处理非直接跳转语句的风险。这种近似可导致检测漏洞系统出现假阳性，更差的情况则是由于不完整的CFG错过漏洞。
- 值-集分析：能缓解该局限性的一种静态分析方法就是\emph{值-集分析}（VSA）。该算法的关键在于，对内存中值的逼近，这个特点在预估非直接跳转语句或内存读写的目标时很有用。这些特点使得VSA借助非直接跳转语句的信息来增强CFG。

## 动态二进制分析
区别于静态二进制分析，动态二进制分析核查程序在给定环境运行时的行为。可以探索独立路径从而更精确，但代价是代码覆盖率下降。而代码覆盖率又是漏洞检测系统一项重要属性，代码覆盖率越大也就越有可能检测到漏洞。

- **具体执行和符号执行**：有两种动态二进制分析方法，即具体执行和符号执行。具体执行是指用实值作为程序输入。符号执行技术使用符号值代替数字值执行程序，得到的变量的值是由输入变 量的符号值和常量组成的表达式。符号执行技术首先由King在1976年提出 ，经过三十多年的发展，现在仍然被广泛研究，它在软件测试和程序验证中发挥着重 要作用。符号执行是一种重要的形式化方法和静态分析技术，它使用数学和逻辑 首先定义一些基本概念。程序的路径是程序的一个语句序列，这个 语句序列包括程序的一些顺序的代码片段，代码片段之间的连接是由于分支语句导致的控制转移。一个路径是可行的，是指存在程序输入变量的至少一组值，如果以这组值作为输入，程序将沿着这条路径执行。否则，路径就是不 可行的。\emph{路径条件}（path condition,PC）是针对一个路径的，它是一 个关于程序输入变量的符号值的约束，一组输入值使得程序沿着这条路径执行当且仅当这组输入值满足这条路径的路径条件。
- **模糊测试**：检测漏洞的主要目标就是找到能触发不安全操作（例如应用崩溃）的输入。模糊测试是具体执行的范例，也是构造输入使系统崩溃的关键技术。但它也有一些局限。模糊测试通常需要手动设置一些测试样例来初始化模糊测试器，之后再基于这些测试样例做调整产生新的输入。针对需要特定值或依赖上下文数据的逻辑分支，标准模糊测试往往不能随机生成值。比如传统模糊测试很难猜出程序执行前生成给用户的认证口令。
- **动态符号执行**：在许多自动化漏洞检测系统中都采用另一种更有效的措施——动态符号执行。在经典的符号执行中，变量和应用输入（如文件、命令行操作等）都使用符号值而不是实值来进行建模。在执行期间，内存和寄存器状态被追踪并被符号建模。符号执行常用于生成驱动路径探索的测试用例，而传统的模糊测试中，测试用例必须手动生成并用于初始化系统。像Mayhem\cite{cha2012unleashing}和S2E\cite{chipounov2011s2e}这样的系统是第一批把这项技术应用于二进制代码的。

	在动态符号执行中，输入和变量都由符号值而不是具体值来表示。这些值被用于生成路径约束，路径约束是表示“程序状态及状态间转变”的逻辑公式。通常这些公式代表程序中之前没探索过的执行路径，并作为satisfiability modulo theories（SMT）求解器的输入。SMT求解器使用这些公式来产生新的应用输入（测试用例）从而驱动应用中新路径的探索。因为大多数编程框架都可以通过支持SMT求解器的理论来建模，因此它常被用在验证和测试程序的工具中。
- **动态符号执行的限制**：动态符号执行的强大源于它能使用学习到的路径约束触发应用状态，使得它成为分析二进制代码漏洞的理想工具。因此被广泛地应用在各大知名二进制分析工具中，如CUTE、KLEE和FuzzBALL。然而，动态符号执行会遇到路径爆炸问题，即每产生一个新分支就有许多新的路径随之而来。这将导致需要探索的路径指数式上涨，也就限制了只使用这种分析技术来探索路径的系统的可用性。

	对这个问题的最新解决方案是结合具体执行和符号执行，即混合执行（concolic execution）。另一种方法是结合动态符号执行和模糊测试，即“有指导”的模糊测试器或有辅助的模糊测试器。该技术让动态符号执行增强输入反传给模糊测试器，从而让动态符号执行驱动路径探索。该技术的目标是最小化计算开销大的操作的使用，比如动态符号执行，并使用代价更小的操作如模糊测试来挖掘应用漏洞，从而提高代码覆盖率。Driller就使用该技术来选择性地使用动态符号执行进行路径探索。Driller是CRS系统Mechanical Phish的关键组件。
## 常见漏洞
像C/C++这样的编程语言允许开发者进行较底层的内存分配，从而达到对应用表现和效率更细粒度的控制。尽管人们一直努力实现各种使系统更安全、可靠的技术，如缓冲区溢出检测和地址空间随机化，像缓冲区溢出这样的漏洞却稳居2015和2016漏洞报告的前三名。

最常见的可利用漏洞就是缓冲区溢出、格式化字符串以及通用的内存覆盖漏洞。这些弱点往往将应用置于险境，即攻击者可以获取敏感数据或劫持控制流从而执行他们选择的任意代码。这也是大多数自动化检测系统希望检测到这些漏洞的原因。

接下来几节将简要介绍这几种常见漏洞类型。

## 缓冲区溢出
当向固定大小的缓冲区写入超过它预先被分配大小的数据时，就会触发缓冲区溢出漏洞。这种漏洞常导致数据覆盖、应用崩溃、对内存中敏感数据的非法访问或允许黑客用自己的代码或库调用替换调用栈中的代码。
## 格式字符串攻击
攻击者使用格式字符串攻击来执行代码或从栈中读取数据。当输入的格式字符串被当作指令执行时即触发该漏洞。这类攻击通常使用ANSI C的printf、fprintf和其他格式字符串函数。
## 通用内存覆盖
缓冲区溢出是内存覆盖的一个范例。当预先分配的内存地址中的数据被偶然或故意修改时即触发该漏洞。被覆盖的数据可能导致应用崩溃。其他内存覆盖的例子包括矩阵索引越界错误、内存分配前使用该地址或者试图使用已经释放的指针。
## CRS系统：Mayhem
Mayhem是针对二进制代码的自动化漏洞挖掘系统。它通过“shell spawning exploit”来确保漏洞是可利用、可验证的。
混合符号执行。它结合了线上、线下的符号执行。\cite{cha2012unleashing}
## 系统简介
漏洞挖掘工具能探索应用的越完全，则越有可能发现可利用的bug。这也给在真实场景中的应用面临的关键挑战，尤其是那些有巨大状态空间需要探索的复杂应用。这也是Mayhem设计过程中的关键目标。

Mayhem的设计者将探索二进制软件视作可能长期运行的进程，对复杂应用尤为如此。这就意味着系统必须有“长线作战”的准备，而同时不能太消耗计算资源。系统效率是Mayhem的另一大顾虑。它通过不重复、不丢弃任何工作来强化这一点，也就是说，所有先前分析的结果都在接下来有用武之地。最后，Mayhem检测漏洞、生成攻击脚本的关键原则是该系统必须能识别在符号内存中，一个加载或存储地址取决于用户输入。
## 框架
Mayhem由两个主要部件组成：\emph{具体执行组件}（Concrete Executor Client，CEC）和\emph{符号执行组件}（Symbolic Executor Server，SES）。SES是操作的大脑，它决定CEC下一个探索的路径，而CEC是路径探索任务的执行者。CEC在目标系统上本地运行，而SES在平台的系统上独立运行。

- CEC：CEC接受二进制文件和输入规范（输入可以来自文件、网络和环境变量），并和SES通信。由于符号执行比而本地（具体）执行要慢，Mayhem尽可能多地采取本地执行。CEC加载并本地执行需要分析的二进制文件，在二进制文件执行过程中，CEC插装代码，以获得运行时状态信息，如内存和寄存器值。CEC还包含污点跟踪器来进行动态污点分析。一旦跟踪器发现条件或跳转语句就中止运行并把信息传给SES。需要注意的是，CEC会一直运行到所有路径探索完或达到某个阈值。
- SES：接收CEC的具体、“污点指令”。这些指令可以是污点分支或污点跳转指令。使用BAP将这些指令从x86汇编转化为中间语言BAP IL。BAP是将x86汇编转化为中间语言的二进制分析工具\cite{brumley2011bap}。SES符号执行CEC输入的代码段。这些指令用来生成两种类型的公式：代表每行代码约束的路径公式以及用来决定攻击者是否能执行脚本或获取指针控制的攻击公式\cite{cha2012unleashing}。这些公式使用SMT求解器\cite{li2014symbolic}求解，它可决定公式是否能被满足。


## 最小化搜索空间及路径选择
CRS系统面临的一项关键挑战就是巨大的执行路径搜索空间。为了应对这点，Mayhem使用了一种叫做条件符号执行的技术，这样用户只需要提供“输入的部分说明”（例如输入长度、前缀等）从而最小化搜索空间。如果没有提供任何说明，则所有的路径都会被探索。
Mayhem使用启发式搜索来决定下一步探索那一些路径。它倾向于那些更有可能有可执行漏洞的路径。那些使用符号内存读取或识别出符号指令指针的路径优先级要大于单纯的新路径。这条优先级排序规则与Mayhem能识别的漏洞类型直接相关。
## 处理符号内存
对生成攻击脚本而言，确认符号内存中加载、储存地址和用户输入的对应关系很重要。为了确认符号内存中的这些地址，CRS系统比需要能对符号内存进行建模和推理。对符号内存建模的难点在于内存表中使用的索引是表达式而不是数字。为了解决这个问题，Mayhem实现了“基于索引的内存建模”。该方法将内存建模为一个映射表，32位的索引被映射到表达式，只有符号读取会按符号建模。
Mayhem使用不可变的“内存对象”来对符号读取进行建模。一旦执行符号读取就新建对象，其中包含符号索引可能访问的所有值。为了新建这样的对象，Mayhem必须找出符号索引的所有可能值。为了使得这个过程更可行，它找的是一系列索引可能值，而不是特定索引值。它使用SMT求解器来求解一系列可能值。使用SMT求解器求解一系列符号目录值开销很大，因此Mayhem首先采用值集分析生成可能索引值的近似中间值来进行优化，之后在输入给SMT来缩小上下限。
## 生成攻击脚本
Mayhem可以识别并生成任意“指令-指针重写”以及格式化字符串攻击的攻击脚本。当它的可利用特性受到冲击时会生成可导出的公式。这些特性是符号污点指令指针，对应于缓冲区溢出或符号字符串攻击对应的符号字符串。
## 实现
Mayhem是C/C++ 和OCaml实现的。它使用Pin来实现它的二进制插装框架。使用BAP来将汇编指令转化中间语言，并使用Z3作为SMT求解器。
## 相关工作
本节简要介绍直接或间接影响Mayhem的关键相关工作。

**自动攻击脚本生成**（AEG）：Mayhem在攻击发现和生成方面的方法很大程度上得益于研究者们在AEG方面的工作。不同于Mayhem，AEG使用源代码分析来发现可利用漏洞，并使用运行时信息来生成对应的攻击脚本。AEG是第一个提供不仅仅是检测可利用漏洞、还生成可验证的攻击脚本来验证安全风险的端到端解决方案的系统。该自动化生成攻击脚本方法解决了光从源代码本身无从得知漏洞是否可利用的问题。尽管源代码提供了许多有用的抽象，但提供不了对决定漏洞是否可利用至关重要的底层细节。AEG同样引入了条件符号执行来最小化搜索空间。

## 系统：Mechanical Phish
Mechanical Phish为DARPA的CGC比赛设计的开源CRS系统。它基于若干开源工具并由几个直接服务于漏洞挖掘和攻击脚本的组件组成。实现Mechanical Phish的漏洞发现功能的两个关键组件就是Angr\cite{shoshitaishvili2016art}和Driller\cite{stephens2016driller}。Driller是一个“有指导的白盒模糊测试器”工具，它利用模糊测试的快速和混合执行的输入推理能力，从而有效且高效的=地发现深层漏洞。Angr是Driller用于实现混合执行引擎的开源二进制分析框架。

接下来的几节将讨论Driller和Angr的设计、一些关键组件的说明、研究者的贡献以及相关工作。所有信息都源于对应的文献。

## Driller
Driller的首要目标是找到任意应用深层逻辑的bug。该目标也是它在模糊测试和动态符号执行的帮住下缓和其缺陷的动机。那些仅实现模糊测试或混合执行的系统，总是由于模糊测试和混合执行自身的缺陷而在代码覆盖的深度和数量受到限制。传统的模糊测试技术虽然快但找不到那些需要特定输入的bug，而混合执行恰是生成这样的输入的有效工具，但面临路径爆炸问题。通过结合这两种技术，Driller可改进混合执行的可扩展性，同时改进模糊测试的有效性。不同于一般只支持发现特定漏洞的系统，Driller可以检测到能导致应用崩溃的任意漏洞。

- 系统简介：设计Driller的核心动机就是它根据应用如何处理输入来划分模糊测试和混合执行能发现的bug的类型。它将应用处理的输入分文两种：通用的和特定的。通用输入可以表示一系列的实值，而只有少量实值。它从直观上将应用划分为不同的“隔间”，特定输入一个一个测试。由于模糊测试生成输入的值十分有效，它常用于在隔间内探索应用路径，而混合执行更适用于求解输入来驱动隔间之间的代码执行。

	Driller由两个主要组件组成：模糊测试器和混合测试引擎。路径爆炸的工作被交给大多数情况下可独立探索大量可执行路径的模糊测试器。这样一来，混合执行引擎只负责解决应用中特定检查所需的更复杂的输入。
**模糊测试器}：模糊测试组建使用非常流行的模糊测试器——American Fuzzy Lop(AFL)。AFL是目前最先进的模糊测试器，它使用基因算法生成输入。它使用插装来进行更多有信息的选择。尽管插装可在编译时引入，Driller使用“QEMU后端”来避免对源代码的需求。路径爆炸的问题也被派给了迷糊测试器。大多数情况下，它能独立探索可执行路径，且速度比混合执行快得多。
**动态符号执行引擎}：动态符号执行引擎使用Angr——一个开源二进制分析框架。该引擎将二进制代码翻译为Valgrind的VEX中间表示（IR）。该IR应用输入对符号状态的影响。所有符号状态中除了常量的值都被建模为符号变量，在程序执行时“符号约束”加入到符号变量中。这些约束定义了符号变量的可能取值的限制条件。在执行期间，具体和符号执行都被追踪，这些值可被用于约束求解器（SMT求解器），从而找到满足当前状态下所有符号变量的约束的值。和Mayhem类似，Driller使用基于索引的内存模型来对符号内存进行建模，其中写地址作为实值储存，而读地址被符号建模。

		当Driller启动时，它首先调用模糊测试器组件。模糊测试器将探索应用，直至它再生成不出驱动执行新路径的输入。当模糊测试器达到该状态时，Driller就认为模糊测试器“停滞”。更具体地说，如果在遍历完一定数量的输入转变后模糊测试器无法前进到新的路径，它就注定“停滞”。当模糊测试器“停滞”时，Driller只接收模糊测试器标记为“感兴趣”的输入，并输入给混合执行引擎。只有触发状态转移的输入会被认为“感兴趣”。
- 最小化搜索空间和路径选择：为了避免动态符号执行引擎中的路径爆炸问题，Driller实现来“预约束追踪”。“预约束追踪”保证了正在分析的路径是代表着应用对特定输入的处理的。
\end{enumerate}

##Angr}
Angr\cite{shoshitaishvili2016art}是一个开源、未知平台的二进制自动化分析工具，它提供了大量用于攻击的二进制分析技术。该框架旨在为研究人员提供一个统一的平台，从而比较这些技术的效果并作为实现、评估新技术的组件。他们的分析工具用到了很多比较复杂的技术，如符号执行（Symbolic Execution）、值-集分析（Value-Set Analysis）等。
\begin{enumerate}
- 动机：许多二进制分析技术都是作为研究原型，对公众不可用。这就意味着未来的研究者们需要从头实现并评估这些技术。为了缓解这个问题，人们创造了Angr
- 系统简介：Angr是一系列Python库。这些库提供了实现各种二进制分析技术的函数：
- 装载二进制程序
- 反汇编和中间表示
- 程序插装
- 符号执行
- 控制流分析
- 数据依赖分析
- 值集分析

Angr的主要设计目标是提供跨结构、跨平台、多种分析技术的支持。因此它的开发者们希望能使用者能借助这个系统在一周内开发任意通用的二进制分析技术。为了实现这个目标，分析引擎被精心设计为严格拆分的一系列软件组件。这项设计使得混合和转化各项分析成为可能\cite{shoshitaishvili2016art}。

本节接下来将Angr中实现的几个关键子模块。

- CLE：CLE是Angr的二进制加载模块。它支持从符合POSIX的系统上加载二进制，如Linux、FreeBSD、Windows以及DARPA为了CGC比赛设计的DECREE OS。
- 中间语言（IR）：由于angr需要处理很多不同的架构，所以它必须将二进制转化为一种中间语言来进行它的分析。Angr中支持IR的模块借助libVEX，并调用python库PyVex来使用python产生libVEX的VEX IR。PyVex最开始是为了Frimalice写的。VEX 使得Angr支持对“ARM、MIPS、PPC和x86处理器的32位和64位版本”的分析。
- SimVex：SimVex模块实现表示及修改程序状态的功能。Angr中的状态（SimState）由一系列“状态”插件表示。这些状态插件提供了实现不同类型二进制分析的建造材料。这些插件提供的功能包括：跟踪寄存器的值，实现符号内存建模，实现抽象内存建模，日志，调试，提供和SMT求解器的交互接口以及对分析有帮助的特定框架信息。
- Claripy：Claripy负责产生代表SimState中储存的值的抽象。Claripy内部将这些值表示为可翻译为各种支持Claripy后端的数据域的表达式。Claripy支持具体域、符号域和值集分析的值集抽象域作为后端。

- 其他关键系统组件：本节简要介绍Angr的其他关键系统组件。以下所有文档都来自Mechanical Phish的github仓库。

- Rex：Rex是最初为CGC设计的自动化攻击引擎。
- Meister：Meister是Mechanical Phish的任务调度器。
- Scriba：Scriba决定提交哪些攻击脚本和可替换的二进制文件（CGC的补丁二进制） 。
- The Ambassador：The Ambassador跟CGC的API交互来获取要挑战的二进制文件、提交漏洞证明等。

## 比较
本文探索了CRS系统中实现的当前最先进的技术。选取了DARPA的CGC比赛的两个赢家系统
——Mayhem和Mechanical Phish作为研究对象。本文的目标是这两个系统的异同，从而找到它们的区分点以及在构造成功检测可利用漏洞、生成攻击脚本的自动化系统时，哪些方法在解决诸多问题时效果最好。本节将展开Mayhem和Mechanical Phish几个关键不同点的简要讨论。
## 路径爆炸
Mayhem和Mechanical Phish都利用来动态符号执行来驱动路径探索，但采取来不同的方法缓解路径爆炸。动态符号执行是发掘二进制代码漏洞的常用手段，且在简单、复杂输入驱动路径探索上都有良好效果。然而，动态符号执行始终面临路径爆炸的问题，因为每个条件分支都会产生新的路径。这将导致需要探索的路径的指数式增长，使得计算开销巨大，影响到只使用这一种方法来进行路径探索的分析系统的可用性。因此，任何使用该技术的系统都必须解决这个问题。
### 混合符号执行
Mayhem使用混合符号执行作为路径探索的主要方法。为了对抗路径爆炸问题，它实现来混合符号执行。混合符号执行允许系统在线上和线下两种符号执行模式中进行切换
### 使用符号执行强化模糊测试
Mechanical Phish使用Driller来辅助路径探索。Driller使用它的模糊测试器来执行路径探索，并在模糊测试器陷入瓶颈时使用符号执行。该方法的关键是预约束追踪，它确保了正在分析的路径代表了应用对给定输入的处理。
## 未来研究方向} 
这一章简要介绍未来的研究方向。
### 面向漏洞挖掘的深度强化学习
二进制代码和视频游戏中的世界有一定共同性——都取决于状态改变，而状态改变是基于用户定义好的输入和交互。深度强化学习领域的一些研究证明又都智能软件代理能在一些复杂任务中不断学习且发挥出色\cite{mnih2015human}。因此，探索基于深度强化学习构造通用AI代理，像人类分析师一样发现二进制系统中的漏洞是未来的研究方向之一。
##从CVE漏洞信息库中生成攻击代码} 
人类安全分析师或攻击者有能力消化CVE漏洞信息库中的信息，并根据其中的漏洞构造攻击脚本。在构造脚本的过程中，他们不仅仅是在利用现有的漏洞信息，也是在利用历史知识和过去的经验。因此，我们有必要探索构造基于知识的系统，使得它能利用最先进的漏洞挖掘和攻击脚本生成工具的分析能力，从而学习攻击脚本和漏洞的通用特征。这样一来，该系统就能利用学习得到的知识针对指定的漏洞报告自动生成通用攻击脚本。也就是说，该系统不再需要源代码或二进制代码来为指定漏洞生成测试用例（攻击脚本），它只需要源代码或二进制代码来验证生成的测试用例。
##二进制预处理以最小化大型复杂应用的搜索空间}
即便是最先进的CRS系统也有一个关键性的约束，那就是它们并不适用于真实场景中的庞大、复杂应用。在很多方面，二进制分析都可以被看作是一个无任何先验知识的搜索问题。那些庞大、复杂应用的搜索空间通常无比巨大，以至于那些希望对这些应用进行高效分析的系统首先要达到的目标就是能比当前最优的系统更大程度地最小化搜索空间。最小化搜索空间将增大代码覆盖率，从而使得分析攻击能发现更深层的代码缺陷。

在明白以上信息后，我们需要探索创建一个能对二进制代码进行预处理、从而发现应用中的“热点”的系统。“热点”指的是应用中可能存在可利用bug的区域。这些“热点”把应用划分为若干区域。“热点”区域信息、路径约束及其他元数据将作为代码中该区域的指引。该信息和对应的二进制一起输入漏洞检测系统，而漏洞监测系统根据路径约束和元数据直接抵达“热点”区域。一旦系统到达该区域，就执行正常的二进制分析。该预处理步骤使得漏洞检测有更多的先验知识，通过切分软件区域，漏洞检测阶段同一时间需要推理的代码也减少了。
## section{总结} 
CRS是旨在将人类分析师的行为和知识包含在自动化系统中的专家系统，该自动化系统实现的功能包括检测可利用漏洞、生成可验证的攻击代码以及给软件打补丁。这些系统十分复杂，因此搭建它们需要大量专家知识。尽管将CRS应用于真实场景中的复杂应用还有许多问题要解决，目前最先进的系统证明：为二进制软件构造一个无人力介入的自动化漏洞检测、攻击脚本生成、软件打补丁的自动化系统是有极大可能性的。

## Reference

[1]D. Brumley, I. Jager, T. Avgerinos, and E. J. Schwartz.Bap: A binary analysis platform. In International Con-ference on Computer Aided Verification, pages 463–469.Springer, 2011.5

[2]S. K. Cha, T. Avgerinos, A. Rebert, and D. Brumley.Unleashing mayhem on binary code. In Security andPrivacy (SP), 2012 IEEE Symposium on, pages 380–394. IEEE, 2012.3,4,5

[3]V. Chipounov, V. Kuznetsov, and G. Candea. S2e: Aplatform for in-vivo multi-path analysis of software sys-tems. ACM SIGPLAN Notices, 46(3):265–278, 2011.3

[4]Y. Li, A. Albarghouthi, Z. Kincaid, A. Gurfinkel, andM. Chechik. Symbolic optimization with smt solvers.In ACM SIGPLAN Notices, volume 49, pages 607–618.ACM, 2014.5

[5]V. Mnih, K. Kavukcuoglu, D. Silver, A. A. Rusu,J. Veness, M. G. Bellemare, A. Graves, M. Riedmiller,A. K. Fidjeland, G. Ostrovski, et al.  Human-levelcontrol through deep reinforcement learning. Nature,518(7540):529–533, 2015.88

[6]Y. Shoshitaishvili, R. Wang, C. Salls, N. Stephens,M. Polino, A. Dutcher, J. Grosen, S. Feng, C. Hauser,C. Kruegel, et al. The art of war: Offensive techniquesin binary analysis. In IEEE Symposium on Security andPrivacy (S&P), 2016.5,6,7

[7]N. Stephens, J. Grosen, C. Salls, A. Dutcher, R. Wang,J. Corbetta, Y. Shoshitaishvili, C. Kruegel, and G. Vi-gna. Driller: Augmenting fuzzing through selective sym-bolic execution. In Proceedings of the Network and Dis-tributed System Security Symposium, 2016.